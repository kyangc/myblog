title: 计算机网络及Wireshark学习笔记
date: 2015-07-20 20:00:00
categories: 技术
tags: [计算机网络] 
description: 好好学了下计算机网络……

---

## 1、网络通信原理

ISO参考模型：7层协议。

>7 **应用层**：用户接口。常用协议：HTTP、SMTP、FTP、Telnet
>6 **表示层**：数据编解码、加解密。常用协议：ASCII、MPEG、JPEG、MIDI。
>5 **会话层**：负责建立、维护连接。常用协议：NetBIOS、SAP、SDP、NWLink。
>4 **传输层**：提供可靠的数据传输。常用协议：TCP、UDP、SPX。
>3 **网络层**：路由转发、数据包分片。常用协议：IP、IPX。（路由器工作在这里）
>2 **数据链路层**：物理网络传输数据的方法，提供一个寻址方案，找到确实的设备。主要协议：Ethernet、Token Ring、FDDI、AppleTalk。（网桥、交换机工作在这里）
>1 **物理层**：硬件相关。

在传输中，会对传输的数据进行封装，封装的结果叫做协议数据单元`PDU（Protocol Data Unit）`，发送时逐级向下`封装`，接收时逐级向上`解封`。

TCP/IP模型中没有表示层和会话层，协议栈中也没有单独设计相关的协议。以HTTP连接为例，应用层产生HTTP数据包，经过传输层，通过`TCP`协议进行可靠的传输，在网络层通过`IP`对于传输设备进行定位，最终在数据链路层通过加上`以太网相关`的头部，放入物理层进行传输。

网络硬件：

>**集线器**：工作在链路层，将受到的信号转播到每一个端口中。不对Mac进行检查，效率低、半双工模式。
>**交换机**：工作在链路层，将收到的信号转播到对应的MAC地址的端口上，减少了机器拒绝的时间，效率更高，双工。
>**路由器**：工作在网络层，负责在多个网络之间转发数据包。通常使用第三层地址（IP）来标示网络上的唯一设备。

<!-- more -->

## 2、网络底层协议

### 1、地址解析协议`ARP`

正常网络通信中需要用到`逻辑地址`和`物理地址`。

>`逻辑地址`用于不同网络、没有直接相连的设备之间进行通信。
>`物理地址`用于在单一网段中**交换机直接连接的设备之间**进行通信。

在`TCP/IP`协议中，`IP`地址已经完成了到第三层的传输，进一步的为了获取到设备的真实MAC地址进而进行单一网络中的通信，`TCP/IP`协议中使用`ARP(Address Resolution Protocol)`来进行`IP`向`MAC`地址的转换。

这个协议使用两种数据包，一个`ARP`请求，一个`ARP`响应。`ARP`请求通过向全部设备广播ARP请求消息，当网段中符合要求的主机收到消息，将发送`ARP`响应告诉请求者自己的真实MAC地址。

### 2、互联网协议`IP`

在该层的通信中，主要负责跨网络的通信，在这个层面上协议不止一个，但是通行很广的还是`IP`协议，包括`IPv6`和`IPv4`。

v4条件下，`IP`地址被分为2个部分，`网络地址`和`主机地址`，网络地址用来标识局域网，主机地址则是标示这个网络中的设备本身，用于决定哪部分是主机，使用的是`掩码`，`掩码`中标示为1的位代表的是网络地址，剩下的则标示着主机地址。

`IPv4`头部很复杂，包含了很多有用的信息，比较重要的有：

>* **存活时间`TTL`**：定义了在该数据包被丢弃之前所能经历的时间（能够经历的最大路由数目）。数据包被发出时会定义`TTL`，之后每次经历一个路由器，正常情况下都会被减1，当网络拥堵时延较长时有可能被减掉更多（但多数时候不会）。`TTL`的设计原理在于，数据包在网络中传输通常会经历数十个路由器，其中难免会有错误配置的路由，在这种情况下路由器可能做很多事，其中一件就是让这个数据包进入死循环——而这必然会占用大量资源，直至`DoS`的情况出现，`TTL`的设定就是防止这种事情的发生。
>* **`IP`分片**：数据包分片的目的是将一个数据流分为更小的片段，是`IP`为了解决跨越不同类型网络时可靠传输的特性。数据包得分片主要基于第二层协议所使用的`最大传输单元MTU`的大小以及使用这些第二层设备的配置情况。以太网的默认MTU是`1500`，所以说以太网上能传输的最大数据包大小是`1500`字节。当需要传输的`IP`数据包大于`MTU`，将对这个数据包进行分片，分片的过程如下：
>
>	1. 将传输的数据分块
>	2. 将每个`IP`数据包的头部总长度设为每个分片的长度
>	3. 将`IP`数据包头部中的分片标志位置1，除了最后一个数据包（最后一个数据包的Flags所有位都是0）
>	4. 设置每个数据包的分片偏移量（这里注意，偏移量表征的是该`IP`数据包中的数据块对应于原有的大数据块中的偏移量。在MTU=1500情况下，第一个的offset是0，第二个的offset是1500-HeaderLength……）

### 3、传输控制协议`TCP`

最终目的是提供数据**可靠地端到端传递**。该协议工作在第四层。能够处理数据的顺序和错误恢复，并且保证数据能够到到达其应该到达的地方。

`TCP`通信使用端口进行，所有的TCP通信都会使用源端口和目的端口（像电话机一样）。

`TCP`进行数据通信之前会进行著名的`三次握手`：

>1. 由发起链接请求的主机向连接对象送出一个`TCP`数据包，不含数据，只有包头，并且设置`Flags`量中的`SYN`为1，并发送一个`SequenceNumber`给对方。
>2. 目标主机收到`SYN`信号之后，回复`SYN/ACK`信号给发起主机。同时发送一个`AcknowledgeNumber`给对方，这个值等于收到的`SequenceNumber`+1；此外会发送属于目标主机的`SequenceNumber`给发起主机。
>3. 发起主机收到`SYN/ACK`信号之后，检查`AcknowledgeNumber`是否与本地的`SequenceNumber`+1相等，若想等则说明传输无误，回复`ACK`信号给目标主机，并且回复`AcknowledgeNumber`到目标主机，其值为目标主机的`SequenceNumber`+1，目标主机收到信号之后检查`AcknowledgeNumber`是否与本地的`SequenceNumber`+1相等，若想等则说明传输无误，连接建立。

`TCP`停止链接同样要经历几个过程：

>1. 请求结束的主机发送`FIN/ACK`到目的主机。
>2. 目的主机回复`ACK`到请求主机。
>3. 目的主机发送`FIN/ACK`到请求主机。
>4. 请求主机回复`ACK`到目的主机，结束链接。

### 4、用户数据报协议`UDP`

`UDP`主要目的在于提高传输速率，是一种尽力服务，是一种无连接协议。一般依赖于`UDP`的服务会内建其他的可靠性措施。如`DNS`和`DHCP`这种高度依赖传输速度的服务，使用`UDP`作为传输层的协议，并自己实现差错控制的方法。

### 5、互联网控制消息协议`ICMP`

`TCP/IP`协议栈中的一个效用协议，负责提供在`TCP/IP`网络上的设备、服务以及路由器可用性的分析。`ICMP`的类型和作用取决于其`Type`和`Code`域。`Ping`是一个工具，通过发送`ICMP echo`请求数据包来达到检测网络状况的目的。

## 3、高层网络协议

### 1、DHCP

`DHCP`是一个应用层协议，能够让设备自动获取IP地址，DHCP最主要的任务就是在续租过程中向客户端分配IP地址。`DHCP`的续租过程被称为`DORA`过程，分为以下四步：

>1. **发现（`Discover`）**：在客户端启动的时候，首先会广播`Discover`报文（在这报文里面包括了客户端的`MAC`地址）。`Discovery`报文可以理解为：客户端去发现`DHCP Server`。由于是广播，可以保证DHCP server收到这个报文。
>2. **提供（`Offer`）**：`DHCP server`收到这个报文后他就知道某个客户端要请求一个IP地址，`DHCP server`就参照`Discover`报文里面的`MAC`地址,然后从他配置的`DHCP`地址池里面分配一个IP地址。然后把这个地址用`Offer`消息告诉客户端。这个报文里面会把`Discovery`里面客户端的MAC包含进去。客户机收到后比较下`MAC`，发现报文里面的`MAC`和自己的`MAC`一样就会认为这个报文是发给他的。
>3. **请求（`Request`）**：由于`DHCP server`可能有多个，所以客户端发一个`Discovery`就很有可能收到多个`Offer`。这时候客户端必须表示我用哪个`Offer`的地址。所以客户端再次发一个`Request`报文，表明我要用这个`Discovery`的报文。
>4. **确认（`Acknowledge`）**：最后`DHCP server`回一个`ACK`。做一个确定。

### 2、域名系统`DNS`

### 3、超文本传输协议`HTTP`

`HTTP`是万维网的传输机制，允许浏览器通过连接Web服务器浏览网页。

`HTTP GET`过程建立在`TCP`之上，首先是通过三次握手建立连接，而后通过TCP向服务器设定的端口（HTTP通常默认使用80端口，HTTPS默认使用443端口）传递HTTP数据包，包中包含资源标示符、操作资源的方式等等定义。服务器读取请求之后通过发送一个HTTP包返回ACK信息。之后开始传输数据，形式是TCP分片。传输结束之后，服务器传输一个带有响应码的封包结束过程。成功的响应吗是200。

`HTTP POST`的过程也建立在`TCP`之上，过程与上类似，只是在结束之后的响应码通常为302，代表该资源找到。而这个响应的数据包通常也被用于重定向的手段，在其location域指明了客户端被重定向的位置。

### 4、超文本传输安全协议`HTTPS`

HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。

握手过程的简单描述如下：

>1. 浏览器将自己支持的一套加密规则发送给网站。
>2. 网站从中选出一组加密算法与`HASH`算法，并将自己的身份信息以`证书`的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。
>3. 获得网站证书之后浏览器要做以下工作：
>	1. 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
>	2. 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
>	3. 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
>4. 网站接收浏览器发来的数据之后要做以下的操作：
>	1. 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。
>	2. 使用密码加密一段握手消息，发送给浏览器。
>5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。

HTTPS一般使用的加密与HASH算法如下：

>非对称加密算法：RSA，DSA/DSS
>对称加密算法：AES，RC4，3DES
>HASH算法：MD5，SHA1，SHA256

其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。

## 5、监听网络线路

首先，需要一块支持混杂模式的网卡才能嗅探数据包，混杂模式的意思是它允许网卡看到所有流经网络线路数据包的驱动模式。

在集线器环境下进行数据嗅探是最理想的情况，你可以从你的端口中听到所有连接到集线器中的设备的网络通信信息。但是集线器环境已经基本不存在了，所以这个环境下的监听很难实现。

在交换机环境下进行数据嗅探则要复杂得多，因为交换机只会与特定端口进行通信（除某些广播消息外），通常采用的方法有如下几个：

>**端口镜像**：通过设置交换机的镜像端口来实现监听。
>**集线器输出**：将需要监听的端口和监听器接入同一个集线器。（类似作弊）
>**使用网络分流器**：在通信链路中使用分流器监听。
>**使用ARP欺骗**：ARP负责翻译第三层的IP地址到第二层的MAC地址，如果我们污染了ARP缓存，使得目标设备的ip对应于嗅探器的mac，那么所有的进出流量都会经由嗅探器流动，从而也达到了监听的目的。

## 5、Wireshark简单使用说明

* Wireshark的过滤器

>分为捕获过滤器和显示过滤器，这两个过滤器都使用BPF语法进行过滤器的定义。BPF的语法结构为：`n`*`限定词`+`ID`=`原语` 多个`原语`通过`||`、`&&`、`!`连接起来成为一个限定表达式。

限定词分为三种：

>**Type**：数字或字母的意义 `host`(默认)，`net`，`port`……
>**Dir**：指明传输方向是前往还是来自 `src`，`dst`
>**Proto**：指明匹配的协议 `ether`，`ip`，`tcp`……

通过设定各种过滤条件，可以配置出各种符合我们需求的过滤器。

* Wireshark高级特性

>**端点 endpoint**：网络通信中的收发者。
>**会话 conversation**：端点之间的通信。

Wireshark中针对这两者有专门的统计工具，可以看到基于端点或者会话的流量状态。同时，Wireshark中还有基于协议栈的统计工具，可以看到某种协议下的链接占了总连接数的多少部分。

Wireshark同时提供对于Mac、ip地址的解析，可以直观的将MAC转换成对应的ip地址，但是这样会带来额外的DNS开销。可能会让抓包来的数据充斥着DNS数据包。

Wireshark提供对于协议数据包的强制解码能力，可以让你将数据包拆分成多个协议区段以分析。因为Wireshark的开源特性，当需要对某种特定的协议进行解析而软件中没有内置解析方法的时候，可以根据已有的解析文件进行自己编制新的解析文件。

Wireshark可以跟踪TCP流，可以看到TCP流整个过程中的发送情况。可以看到最原始的数据交换。

## 6、利用Wireshark解决网络问题


利用`TCP`数据包的错误恢复特性进行网络环境的检修是非常有用的一件事。


### 1、TCP的错误恢复特性


#### 1、重传机制


决定是否有必要重传的机制叫做重传计时器。这个计时器负责维护一个叫重传超时`RTO`的值，每当使用`TCP`传递一个数据包的时候计时器就启动，当收到这个数据包的ACK的时候计时器停止，这两个时刻之间的值叫做往返时间`RTT`，若干次`RTT`的测量之后得到的值就是`RTO`。在`RTT`值不够多的时候，依靠默认的`RTO`值。

`RTO`值被用于决定发送数据包之后过多久重传数据，当在这段时间内收到ACK信号则不需要重传，否则like重传，并将RTO值翻倍，依次类推直到达到最大重传数。

`TCP`在传递数据的时候，发送者会附带一个`SEQ`值，发送之后将该值自增发送数据包的大小，接受者成功接收之后会回复一个`ACK`值，其值为`SEQ`值和传递的数据包大小之和，若接收端收到的`SEQ`值不等于`ACK`那么为了保证数据的有序性，接收端会回复，该`ACK`值；发送者检查现在的`SEQ`和收到的`ACK`值是否一致，若连续三次检测到不一致，则代表数据丢失，则会按照接收端传回的`ACK`值发送数据包，完成数据重传。

当发送端认为接收端没有收到数据的时候会重传数据，这是通过`RTO`完成的，由发送端决定；当发送端收到连续三次接收端相同数据`ACK`的时候，也会临时重传数据，这是由接收端决定的。


#### 2、流控制


`TCP`使用滑动窗口技术来检测何时发生了数据包丢失并调整数据传递速率以加以避免。

通常接受主机有一个缓冲区和一个接收窗口，发送主机只能发送大小小于接收窗口的数据包，接受主机在接受了一定数量的数据之后会处理缓冲区中的数据，并返回`ACK`给发送主机，在`ACK`中更新窗口大小。如果接收机认为发送机的发送速率自己能够处理得过来，那么窗口大小不变；如果认为发送速度太快，那么将减小窗口大小；如果已经完全无法接收数据，那么将回设窗口大小为0。

### 2、定位网络延迟

通常关注六个数据包：三次握手、初始`HTTP GET`请求、对该请求的确认以及第一个数据包：

>1. A -> B:`SYNC`
>2. B -> A:`SYNC/ACK`
>3. A -> B:`ACK`
>4. A -> B:`GET`
>5. B -> A:`ACK`
>6. B -> A:`DATA`

通常的，我们只关心这些步骤之间的延迟。通常的，异常的高延迟通常代表了以下的内容：

>1. 在三次握手中，通常接收到信号->回发送信号的过程是很难被影响到的，基本不会是因为这个原因产生延迟，因此在这个阶段的延迟通常都来自于网络传输。
>2. 从握手完毕到发送`GET`请求这个过程可能会因为客户端的处理器忙带来延迟。
>3. 从发出`GET`信号到收到服务器的确认消息的过程基本也只会被线路延迟影响。
>4. 从服务器发送`ACK`信号之后到第一次发送数据，这段时间可能会受到服务器的负载影响。